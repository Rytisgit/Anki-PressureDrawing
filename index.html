<html><head></head><body style="background: black;"><div id="canvas_wrapper" style="touch-action: none;">
    <canvas id="main_canvas" width="2562" height="1309" style="height: 1309px;"></canvas>
</div>
<div id="pencil_button_bar">
    <input type="button" class="active" onclick="active=!active;switch_visibility();switch_class(this, 'active');" value="Hide" title="Toggle visiblity">
    <input type="button" onclick="ts_undo();" value="Undo" title="Undo the last stroke" id="ts_undo_button" class="active">
    <input type="button" class="active" onclick="clear_canvas();" value="Clean" title="Clean whiteboard">
</div>
<style>
body {
  //overflow-y: hidden; /* Hide vertical scrollbar */
  overflow-x: hidden; /* Hide horizontal scrollbar */
}
body::-webkit-scrollbar {
  display: none;
}

#canvas_wrapper, #main_canvas
{
    position:absolute;
    top: 0px;
    left: 0px;
    z-index: 999;
}
#main_canvas{
    opacity: """ + str(ts_opacity) + """;
	//pointer-events:none
}
.night_mode #pencil_button_bar input[type=button].active
{
    color: #fff!important;
}
#pencil_button_bar input[type=button].active
{
    color: black!important;
}
#pencil_button_bar
{
    position: fixed;
    bottom: 1px;
    right: 1px;
    z-index: 1000;
    font-family: "Arial Unicode MS", unifont, "Everson Mono", tahoma, arial;
}
#pencil_button_bar input[type=button]
{
    border: 1px solid black;
    margin: 0 1px;
    display: inline-block;
    float: left;
    width: 120px!important;
    font-size: 100%;
    line-height: 60%;
    height: 80px;
    border-radius: 8px;
    background-color: rgba(250,250,250,0.5)!important;
    color: black;
    color: #ccc!important;
}
.night_mode #pencil_button_bar input[type=button]{
    background-color: rgba(10,10,10,0.5)!important;
    border-color: #ccc;
    color: #444!important;
    text-shadow: 0 0 1px rgba(5, 5, 5, 0.9);
}
#canvas_wrapper
{
    height: 100px
}
</style>

<script>
var visible = true;
var canvas = document.getElementById('main_canvas');
var wrapper = document.getElementById('canvas_wrapper');
var ts_undo_button = document.getElementById('ts_undo_button');
var ctx = canvas.getContext('2d');
var arrays_of_points = [ ];
var color = 'grey';
var line_width = 4;
var card = true;

canvas.onselectstart = function() { return false; };
wrapper.onselectstart = function() { return false; };

function switch_visibility()
{
    if (visible)
    {
        canvas.style.display='none';
    }
    else
    {
        canvas.style.display='block';
    }
    visible = !visible;
}

function switch_class(e,c)
{
    var reg = new RegExp('(\\\s|^)' + c + '(\\s|$)');
    if (e.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)')))
    {
        e.className = e.className.replace(reg, '');
    }
    else
    {
        e.className += c;
    }
}

function resize() {
    var card = document.getElementsByClassName('card')[0]
    ctx.canvas.width = window.innerWidth-1;
    ctx.canvas.height = Math.max(
        document.body.clientHeight,
        window.innerHeight,
        card ? card.scrollHeight : 0
    )-1;

    canvas.style.height = ctx.canvas.height + 'px';
    wrapper.style.width = ctx.canvas.width + 'px';
	/* Get DPR with 1 as fallback */
    var dpr = window.devicePixelRatio || 1;
    dpr = dpr > 1 ? dpr : 1;
    /* CSS size is the same */
    canvas.style.height = ctx.canvas.height + 'px';
    wrapper.style.width = ctx.canvas.width + 'px';
    
    /* Increase DOM size and scale */
    ctx.canvas.width *= dpr;
    ctx.canvas.height *= dpr;
    ctx.scale(dpr, dpr);
    update_pen_settings()
}


window.addEventListener('resize', resize);
window.addEventListener('load', resize);
window.requestAnimationFrame(draw_last_line_segment);

var isPointerDown = false;
var mouseX = 0;
var mouseY = 0;
var active = true;

function update_pen_settings(){
    ctx.lineJoin = ctx.lineCap = 'round';
    ctx.lineWidth = line_width;
    ctx.strokeStyle = color;
    ts_redraw()
}

function ts_undo(){
	stop_drawing();//doesnt work right? to stop drawing afer undo
    arrays_of_points.pop()
    if(!arrays_of_points.length)
    {
        ts_undo_button.className = ""
    }
    ts_redraw()
}

function ts_redraw() {
	pleaseRedrawEverything = true;
}

function clear_canvas()
{
	//don't continue to put points into an empty array(pointermove) if clearing while drawing on the canvas
	stop_drawing();
    arrays_of_points=[];
	ts_redraw();
}

function stop_drawing(){
	isPointerDown = false;
	drawingWithPressurePenOnly = false;
}

function draw_last_line_segment() {
    window.requestAnimationFrame(draw_last_line_segment);
    draw_upto_latest_point_async(lastLine, lastPoint)
}

var lastLine = 0;
var lastPoint = 0;
var p1,p2,p3;

async function draw_path_at_some_point_async(startX, startY, midX, midY, endX, endY, lineWidth) {
		ctx.beginPath();
		ctx.moveTo((startX + (midX - startX) / 2), (startY + (midY - startY)/ 2));
		ctx.quadraticCurveTo(midX, midY, (midX + (endX - midX) / 2), (midY + (endY - midY)/ 2));
		//ctx.lineTo(endX, endY);
		ctx.lineWidth = lineWidth;
		ctx.stroke();
};
//Weird bug or feature of canvas?? : ending of the previous line gets a tiny bit wider at the end when a new line is drawn
var pleaseRedrawEverything = false;
async function draw_upto_latest_point_async(startLine, startPoint){
	//Don't keep redrawing the same last point over and over
	if(!pleaseRedrawEverything && startLine == arrays_of_points.length-1 && startPoint == arrays_of_points[startLine].length-1) return;
	
	var fullRedraw = false;//keep track if this call started a full redraw to unset pleaseRedrawEverything flag later.
	if (pleaseRedrawEverything) {// erase everything and draw from start
	fullRedraw = true;
	startLine = 0;
	startPoint = 0;
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	}
	for(var i = startLine; i < arrays_of_points.length; i++){ 
		lastLine = i;
		///0,0,0; 0,0,1; 0,1,2 or x+1,x+2,x+3
		//take the 2 previous points in addition to current one at the start of the loop.
		p2 = arrays_of_points[i][startPoint > 1 ? startPoint-2 : 0];
		p3 = arrays_of_points[i][startPoint > 0 ? startPoint-1 : 0];
        for(var j = startPoint; j < arrays_of_points[i].length; j++){
			lastPoint = j;
			p1 = p2;
			p2 = p3;
			p3 = arrays_of_points[i][j];
			draw_path_at_some_point_async(p1[0],p1[1],p2[0],p2[1],p3[0],p3[1],p3[2]);
        }
		startPoint = 0;
    }
	if (fullRedraw) {//finished full redraw can unset redraw all flag so no more full redraws until necesarry
	pleaseRedrawEverything = false;
	fullRedraw = false;
	lastLine = 0;
	lastPoint = 0;
	}
}

var drawingWithPressurePenOnly = false; // hack for drawing with 2 main pointers when using a presure sensitive pen

canvas.addEventListener("pointerdown", function (e) {
	if (!e.isPrimary) { return; }
	if (e.pointerType[0] == 'p') { drawingWithPressurePenOnly = true }
	else if ( drawingWithPressurePenOnly) { return; }
    if(!isPointerDown){
        event.preventDefault();
        arrays_of_points.push([[
			e.offsetX,
			e.offsetY,
			e.pointerType[0] == 'p' ? (0.5 + e.pressure * line_width * 2) : line_width]]);
        ts_undo_button.className = "active"
		isPointerDown = true;
    }
});

canvas.addEventListener("pointermove", function (e) {
	if (!e.isPrimary) { return; }
	if (e.pointerType[0] != 'p' && drawingWithPressurePenOnly) { return; }
    if (isPointerDown && active) {
        arrays_of_points[arrays_of_points.length-1].push([
			e.offsetX,
			e.offsetY,
			e.pointerType[0] == 'p' ? (0.5 + e.pressure * line_width * 2) : line_width]);
    }
});

window.addEventListener("pointerup",function (e) {
    /* Needed for the last bit of the drawing. */
	if (!e.isPrimary) { return; }
	if (e.pointerType[0] != 'p' && drawingWithPressurePenOnly) { return; }
     if (isPointerDown && active) {
        arrays_of_points[arrays_of_points.length-1].push([
			e.offsetX,
			e.offsetY,
			e.pointerType[0] == 'p' ? (e.pressure * line_width * 2) : line_width]);
    } 
	stop_drawing();
});

document.addEventListener('keyup', function(e) {
    // Z or z or .
    if ((e.keyCode == 90 || e.keyCode == 122) && e.altKey || e.key === ".") {
		e.preventDefault()
        ts_undo()
    }
    // /
    if (e.key === "/") {
        clear_canvas()
    }
	// ,
    if (e.key === ",") {
        switch_visibility()
    }
})

</script></body></html>